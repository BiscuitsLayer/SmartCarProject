#version 430

// Define the size of the local work group 
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// WARNING: std430 will pad your struct of vec3 out to the size of a vec4
struct BBox {
    vec4 min_point;
    vec4 max_point;
    mat4 model;
    mat4 mesh_to_model;
};

layout (std430, binding = 0) readonly buffer ObstaclesBlock {
    BBox obstacle_bboxes[];
};

layout (std430, binding = 1) readonly buffer CarPartsBlock {
    BBox car_parts_bboxes[];
};

layout(std430, binding = 2) writeonly buffer IntersetionResultsBlock {
    float intersection_results[];
};

bool Intersect(vec4 obstacle_min_point, vec4 obstacle_max_point, vec4 car_parts_min_point, vec4 car_parts_max_point) {
    return (obstacle_min_point.x <= car_parts_max_point.x) && (obstacle_max_point.x >= car_parts_min_point.x)
    && (obstacle_min_point.y <= car_parts_max_point.y) && (obstacle_max_point.y >= car_parts_min_point.y)
    && (obstacle_min_point.z <= car_parts_max_point.z) && (obstacle_max_point.z >= car_parts_min_point.z);
}

void main() {
    uint obstacle_id = gl_GlobalInvocationID.x;
    uint car_parts_id = gl_GlobalInvocationID.y;

    uint obstacles_size = gl_NumWorkGroups.x;
    uint car_parts_size = gl_NumWorkGroups.y;

    BBox obstacle_bbox = obstacle_bboxes[obstacle_id];
    vec4 obstacle_min_point = obstacle_bbox.model * obstacle_bbox.mesh_to_model * obstacle_bbox.min_point;
    vec4 obstacle_max_point = obstacle_bbox.model * obstacle_bbox.mesh_to_model * obstacle_bbox.max_point;

    BBox car_parts_bbox = car_parts_bboxes[car_parts_id];
    vec4 car_parts_min_point = car_parts_bbox.model * car_parts_bbox.mesh_to_model * car_parts_bbox.min_point;
    vec4 car_parts_max_point = car_parts_bbox.model * car_parts_bbox.mesh_to_model * car_parts_bbox.max_point;

    bool result = Intersect(obstacle_min_point, obstacle_max_point, car_parts_min_point, car_parts_max_point);
    intersection_results[obstacle_id * car_parts_size + car_parts_id] = result ? 1 : 0;
}